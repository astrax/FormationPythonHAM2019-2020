TITLE: TD N°4 : Intégration numérique
AUTHOR: Ahmed Ammar {copyright|CC BY} Email:ahmed.ammar@fst.utm.tn at Institut Préparatoire aux Études Scientifiques et Techniques, Université de Carthage.
DATE: today

TOC: on

!split
===== Exercise: Valeur approchée de $\pi$ =====
Étant donnée l'égalité:
!bt
\begin{equation}
\pi = 4 \left( \int_0^\infty e^{-x^2} dx \right)^2 = 4 \left( \int_0^{10} e^{-x^2} dx + \epsilon \right)^2
\end{equation}
!et
avec $0 < \epsilon < 10^{−44}$ , utiliser la méthode des trapèzes composite à $10$ intervalles pour estimer la valeur de $\pi$.
!bsol
La méthode des trapèzes composite à $n$ intervalles pour calculer l’intégrale d’une fonction f sur l’intervalle $[a, b]$ s’écrit
!bt
\begin{equation*}
\int_a^b f(x)\,dx \approx h \left[\frac{1}{2}f(x_0) + \sum_{i=1}^{n-1}f(x_i) + \frac{1}{2}f(x_n) \right]
\end{equation*}
!et
avec $h = \frac{b-a}{n}$ et $x_i = a + ih,\quad i = 0,1,\ldots,n$

Ici on a $f (x) = e^{-x}$ , $a = 0$, $b = 10$, $n = 10$ d’où $h = 1$ et on obtient
!bt
\begin{equation*}
I \approx \frac{1}{2} + \sum_{i=1}^{9} e^{-i} + \frac{1}{2e^{100}} = \frac{1}{2} + \frac{1}{e} + \frac{1}{e^{4}} + \frac{1}{e^{9}} + \frac{1}{e^{16}} + \frac{1}{e^{25}} + \frac{1}{e^{36}} + \frac{1}{e^{49}} + \frac{1}{e^{64}} + \frac{1}{e^{81}} + \frac{1}{2e^{100}}
\end{equation*}
!et
ainsi en utilisant la fonction `trapeze(f,a,b,n)` du module `trapeze_integral.py` décrite dans le cours comme suit
!bc pycod
from trapeze_integral import trapeze
from math import exp
f = lambda x: exp(-x**2)
I = trapeze(f, 0, 10, 10)
print(4*I**2)
!ec
on obtient $\pi \approx 4I^2 = 3.14224265994$.
!esol

!split
===== Exercise: Intégration adaptative =====
label{ex:adaptatif}

Supposons que nous voulons utiliser la méthode des trapèzes ou du point milieu pour calculer une intégrale $\int_a^b f(x)dx$ avec une erreur inférieure à une tolérance prescrite $\epsilon$. Quelle est la taille appropriée de $n$?

Pour répondre à cette question, nous pouvons entrer une procédure itérative où nous comparons les résultats produits par $n$ et $2n$ intervalles, et si la différence est inférieure à $\epsilon$, la valeur correspondant à $2n$ est retournée. Sinon, nous avons $n$ et répétons la procédure.
!bhint
Il peut être une bonne idée d'organiser votre code afin que la fonction `integration_adaptive` peut être utilisé facilement dans les programmes futurs que vous écrivez.
!ehint

!bsubex

Écrire une fonction `integration_adaptive(f, a, b, eps, method=midpoint)` qui implémente l'idée ci-dessus (`eps` correspond à la tolérance $\epsilon$, et la méthode peut être `midpoint` ou `trapeze`).
!bsol
En facilitant les réponses à l'ensemble de cet exercice, ainsi qu'en préparant l'utilisation facile de l'intégration adaptative dans les futurs programmes, nous organisons le codage des tâches a, b et c en un seul fichier, ce qui en fait un module. Le code se lit alors:
!bc pycod
from numpy import linspace, zeros, sqrt, log
from trapezoidal import trapezoidal
from midpoint import midpoint

def adaptive_integration(f, a, b, eps, method='midpoint'):
    n_limit = 1000000   # Just a choice (used to avoid inf loop)
    n = 2
    if method == 'trapezoidal':
        integral_n  = trapezoidal(f, a, b, n)
        integral_2n = trapezoidal(f, a, b, 2*n)
        diff = abs(integral_2n - integral_n)
        print 'trapezoidal diff: ', diff
        while (diff > eps) and (n < n_limit):
            integral_n  = trapezoidal(f, a, b, n)
            integral_2n = trapezoidal(f, a, b, 2*n)
            diff = abs(integral_2n - integral_n)
            print 'trapezoidal diff: ', diff
            n *= 2
    elif method == 'midpoint':
        integral_n  = midpoint(f, a, b, n)
        integral_2n = midpoint(f, a, b, 2*n)
        diff = abs(integral_2n - integral_n)
        print 'midpoint diff: ', diff
        while (diff > eps) and (n < n_limit):
            integral_n  = midpoint(f, a, b, n)
            integral_2n = midpoint(f, a, b, 2*n)
            diff = abs(integral_2n - integral_n)
            print 'midpoint diff: ', diff
            n *= 2
    else:
        print 'Error - adaptive integration called with unknown par'
    # Now we check if acceptable n was found or not
    if diff <= eps:   # Success
        print 'The integral computes to: ', integral_2n
        return n
    else:
        return -n   # Return negative n to tell "not found"

def application():
    """...Tasks b) and c)"""

    def f(x):
        return x**2
    def g(x):
        return sqrt(x)

    #eps = 1E-1           # Just switch between these two eps values
    eps = 1E-10
    #a = 0.0
    a = 0.0 + 0.01;       # If we adjust a, sqrt(x) is handled easily
    b = 2.0
    # ...f
    n = adaptive_integration(f, a, b, eps, 'midpoint')
    if n > 0:
        print 'Sufficient n is: %d' % (n)
    else:
        print 'No n was found in %d iterations' % (n_limit)

    n = adaptive_integration(f, a, b, eps, 'trapezoidal')
    if n > 0:
        print 'Sufficient n is: %d' % (n)
    else:
        print 'No n was found in %d iterations' % (n_limit)

    # ...g
    n = adaptive_integration(g, a, b, eps, 'midpoint')
    if n > 0:
        print 'Sufficient n is: %d' % (n)
    else:
        print 'No n was found in %d iterations' % (n_limit)

    n = adaptive_integration(g, a, b, eps, 'trapezoidal')
    if n > 0:
        print 'Sufficient n is: %d' % (n)
    else:
        print 'No n was found in %d iterations' % (n_limit)

    # Task c, make plot for both midpoint and trapezoidal
    eps = linspace(1E-1,10E-10,10)
    n_m = zeros(len(eps))
    n_t = zeros(len(eps))
    for i in range(len(n_m)):
        n_m[i] = adaptive_integration(g, a, b, eps[i], 'midpoint')
        n_t[i] = adaptive_integration(g, a, b, eps[i], 'trapezoidal')

    import matplotlib.pyplot as plt
    plt.plot(log(eps),n_m,'b-',log(eps),n_t,'r-')
    plt.xlabel('log(eps)')
    plt.ylabel('n for midpoint (blue) and trapezoidal (red)')
    plt.show()
    print n
    print eps

if __name__ == '__main__':
    application()

!ec
!esol

!esubex

!bsubex
Testez la méthode sur $\int_0^2x^2dx$ et $\int_0^2\sqrt{x}dx$ pour $\epsilon = 10^{−1},10^{−10}$ et notez l'erreur exacte.
!bsol
Voir le code ci-dessus. Notez que, dans notre code suggéré, il est prévu que le programmeur bascule entre les deux valeurs epsilon en utilisant des commentaires, c'est-à-dire en ajoutant/supprimant `#`. Cela peut bien sûr être évité, si cela est souhaitable, en demandant à l'utilisateur d'entrer un valeur d'epsilon.
!esol

!esubex

!bsubex
Faites un tracé de $n$ en fonction de $\epsilon \in [10^{-1}, 10^{-10}]$ pour $\int_0^2\sqrt{x}dx$. Utilisez l'échelle logarithmique pour $\epsilon$.
!bsol
La figure 14 montre que plus la valeur d'epsilon est stricte, plus la différence entre les méthodes du point milieu et des trapèzes est grande. Pour une valeur donnée pour epsilon, la méthode du point médian se situe dans la tolérance avec moins d'intervalles (valeur inférieure de $n$) que la méthode des trapèzes. Il faut s'y attendre, car la méthode du point milieu est un peu plus précise que la méthode des trapèzes.

Une façon de produire ce tracé est d'utiliser les lignes de code incluses à la fin de `integration_adaptive.py` (voir ci-dessus).

!esol

!esubex

!bremarks
Le type de méthode exploré dans cet exercice est appelé *adaptatif*, car il essaie d'adapter la valeur de n pour répondre à un critère d'erreur donné. La vraie erreur peut très rarement être calculée (car nous ne connaissons pas la réponse exacte au problème de calcul), il faut donc trouver d'autres indicateurs de l'erreur, comme celui ici où les changements de la valeur intégrale, comme le nombre d'intervalles est doublé, est pris pour refléter l'erreur.
!eremarks

!split
===== Exercise: Intégration de x élevé à x =====
Considérons l'intégrale
!bt
\begin{equation*}
I = \int_0^2 x^x\,dx\thinspace .
\end{equation*}
!et
L'intégrande $x^x$ n'a pas de primitive qui peut être exprimé en termes de fonctions standard (visitez URL:"http://wolframalpha.com" et tapez `integral x^x dx from 0 to 2` pour vous convaincre que notre affirmation est juste. Notez que Wolfram alpha vous donne une réponse, mais cette réponse est une approximation, elle n'est pas *exacte*. C'est parce que Wolfram alpha utilise également des méthodes numériques pour arriver à la réponse, comme vous le ferez dans cet exercice). Par conséquent, nous sommes obligés de calculer l'intégrale par des méthodes numériques. Calculez un résultat composé de quatre chiffres.
!bhint
Utilisez des idées de l'exercice ref{ex:adaptatif}.
!ehint
!bsol
Lorsque la fonction `integration_adaptive` est disponible, le code peut s'écrire:
!bc pycod
from integration_adaptive import integration_adaptive

def f(x):
    return x**x

eps = 1E-4
a = 0.0;  b = 2.0

# Choose midpoint method
n = integration_adaptive(f, a, b, eps, 'midpoint')
if n > 0:
    print 'Sufficient n is: %d' % (n)
else:
    # The negative n is returned to signal that the upper limit of n
    # was passed
    print 'No n was found in %d iterations' % (abs(n))
!ec
N'oubliez pas que `integration_adaptive` affiche l'intégrale calculée, donc aucun effort à cet égard n'est requis ici.

L'exécution du programme donne une impression à l'écran montrant comment la différence devient de plus en plus petite à chaque fois. Les deux dernières lignes de l'impression se lisent comme suit:
!bc
The integral computes to: 2.83384395958
Sufficient n is: 256
!ec
La valeur calculée peut être comparée à ce que donne Wolfram alpha. N'oubliez pas qu'étant donné que nous n'avons pas calculé l'erreur exacte, nous ne pouvons garantir que le "résultat est correct à quatre chiffres". Cependant, nous avons des raisons de croire que nous "sommes proches". Typiquement, lorsque l'on sait que la mesure d'erreur utilisée n'est pas précise, la tolérance est rendue plus stricte.
!esol
